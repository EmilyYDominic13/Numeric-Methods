#MÉTODO DE BISECCIÓN

#Código para realizar el método de bisección para ec. no lineales      #20/08/24
#Para agregarle una matriz con los valores obtenidos

import numpy as np

print('\t\t\tPrograma que resuelve ec. no lineales mediante el método de bisección.\t\t\t\n')
fx = input('Ingresa la función f(x): ')

#Volviendo la función evaluable
f = eval(f'lambda x:{fx}')

#Solicitamos los valores a y b
a = float(input("Ingresa el valor del extremo inferior 'a': "))
b = float(input("Ingresa el valor del extremo superior 'b': "))

#Pedimos valores del criterio de paro: TOL y núm. de iteraciones
tol = float(input("Establece la tolerancia: "))
itmax = int(input("Ingresa el valor máximo de iteraciones: "))

i = 1
FA = f(a)

#Creamos el arreglo
tabla = [] #arreglo vacío/lista vacía

while (i<=itmax):
  p = a + (b-a)/2 #(a+b)/2
  FP = f(p)
  error = (b-a)/2
  if (FP==0 or error<tol):
    break
  else:
    tabla.append([i,p,error]) #como es un arreglo lo ponemos entre corchetes
    i+=1
  if (FA*FP>0):
    a = p
    FA = FP
  else:
    b = p

tabla.append([i,p,error]) #se agregan los últimos cálculos realizados
tabla = np.array(tabla) #Transfromando la tabla a un arreglo en 2D

#Imprimiendo resultados
if (i>itmax):
  print('\n ERROR, se alcanzó el máximo de viteraciones, pero no la tolerancia...')
else:
  print('\n El valor aproximado de la raíz es: ', p)
  print(' Se obtuvo en la iteración ', i, '.')
  print('\n', tabla)
